<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FrontEnd/Restoran/lib/api.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FrontEnd/Restoran/lib/api.ts" />
              <option name="originalContent" value="// This file is kept for reference but is not used in the application&#10;&#10;/*&#10;import { AuthService } from &quot;./auth&quot;&#10;&#10;const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || &quot;http://localhost:5000/api&quot;&#10;&#10;export class ApiClient {&#10;  private static getHeaders(): HeadersInit {&#10;    const token = AuthService.getToken()&#10;    return {&#10;      &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;      ...(token &amp;&amp; { Authorization: `Bearer ${token}` }),&#10;    }&#10;  }&#10;&#10;  static async get&lt;T&gt;(endpoint: string): Promise&lt;T&gt; {&#10;    const response = await fetch(`${API_BASE_URL}${endpoint}`, {&#10;      method: &quot;GET&quot;,&#10;      headers: this.getHeaders(),&#10;    })&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`API Error: ${response.statusText}`)&#10;    }&#10;&#10;    return response.json()&#10;  }&#10;&#10;  static async post&lt;T&gt;(endpoint: string, data: unknown): Promise&lt;T&gt; {&#10;    const response = await fetch(`${API_BASE_URL}${endpoint}`, {&#10;      method: &quot;POST&quot;,&#10;      headers: this.getHeaders(),&#10;      body: JSON.stringify(data),&#10;    })&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`API Error: ${response.statusText}`)&#10;    }&#10;&#10;    return response.json()&#10;  }&#10;&#10;  static async put&lt;T&gt;(endpoint: string, data: unknown): Promise&lt;T&gt; {&#10;    const response = await fetch(`${API_BASE_URL}${endpoint}`, {&#10;      method: &quot;PUT&quot;,&#10;      headers: this.getHeaders(),&#10;      body: JSON.stringify(data),&#10;    })&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`API Error: ${response.statusText}`)&#10;    }&#10;&#10;    return response.json()&#10;  }&#10;&#10;  static async delete&lt;T&gt;(endpoint: string): Promise&lt;T&gt; {&#10;    const response = await fetch(`${API_BASE_URL}${endpoint}`, {&#10;      method: &quot;DELETE&quot;,&#10;      headers: this.getHeaders(),&#10;    })&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`API Error: ${response.statusText}`)&#10;    }&#10;&#10;    return response.json()&#10;  }&#10;}&#10;*/&#10;&#10;// Note: All API calls have been replaced with static mock data&#10;// Each page component uses local state and setTimeout to simulate API delays&#10;export {}&#10;" />
              <option name="updatedContent" value="import { AuthService } from &quot;./auth&quot;&#10;&#10;const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || &quot;http://localhost:5000/api&quot;&#10;&#10;export class ApiClient {&#10;  private static getHeaders(): HeadersInit {&#10;    const token = AuthService.getToken()&#10;    return {&#10;      &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;      ...(token &amp;&amp; { Authorization: `Bearer ${token}` }),&#10;    }&#10;  }&#10;&#10;  static async get&lt;T&gt;(endpoint: string): Promise&lt;T&gt; {&#10;    const response = await fetch(`${API_BASE_URL}${endpoint}`, {&#10;      method: &quot;GET&quot;,&#10;      headers: this.getHeaders(),&#10;    })&#10;&#10;    if (!response.ok) {&#10;      const error = await response.json().catch(() =&gt; ({ message: response.statusText }))&#10;      throw new Error(error.message || `API Error: ${response.statusText}`)&#10;    }&#10;&#10;    return response.json()&#10;  }&#10;&#10;  static async post&lt;T&gt;(endpoint: string, data: unknown): Promise&lt;T&gt; {&#10;    const response = await fetch(`${API_BASE_URL}${endpoint}`, {&#10;      method: &quot;POST&quot;,&#10;      headers: this.getHeaders(),&#10;      body: JSON.stringify(data),&#10;    })&#10;&#10;    if (!response.ok) {&#10;      const error = await response.json().catch(() =&gt; ({ message: response.statusText }))&#10;      throw new Error(error.message || `API Error: ${response.statusText}`)&#10;    }&#10;&#10;    return response.json()&#10;  }&#10;&#10;  static async put&lt;T&gt;(endpoint: string, data: unknown): Promise&lt;T&gt; {&#10;    const response = await fetch(`${API_BASE_URL}${endpoint}`, {&#10;      method: &quot;PUT&quot;,&#10;      headers: this.getHeaders(),&#10;      body: JSON.stringify(data),&#10;    })&#10;&#10;    if (!response.ok) {&#10;      const error = await response.json().catch(() =&gt; ({ message: response.statusText }))&#10;      throw new Error(error.message || `API Error: ${response.statusText}`)&#10;    }&#10;&#10;    return response.json()&#10;  }&#10;&#10;  static async patch&lt;T&gt;(endpoint: string, data: unknown): Promise&lt;T&gt; {&#10;    const response = await fetch(`${API_BASE_URL}${endpoint}`, {&#10;      method: &quot;PATCH&quot;,&#10;      headers: this.getHeaders(),&#10;      body: JSON.stringify(data),&#10;    })&#10;&#10;    if (!response.ok) {&#10;      const error = await response.json().catch(() =&gt; ({ message: response.statusText }))&#10;      throw new Error(error.message || `API Error: ${response.statusText}`)&#10;    }&#10;&#10;    return response.json()&#10;  }&#10;&#10;  static async delete&lt;T&gt;(endpoint: string): Promise&lt;T&gt; {&#10;    const response = await fetch(`${API_BASE_URL}${endpoint}`, {&#10;      method: &quot;DELETE&quot;,&#10;      headers: this.getHeaders(),&#10;    })&#10;&#10;    if (!response.ok) {&#10;      const error = await response.json().catch(() =&gt; ({ message: response.statusText }))&#10;      throw new Error(error.message || `API Error: ${response.statusText}`)&#10;    }&#10;&#10;    // DELETE may not return content&#10;    if (response.status === 204) {&#10;      return {} as T&#10;    }&#10;&#10;    return response.json()&#10;  }&#10;}&#10;&#10;// Restaurant API&#10;export const restaurantApi = {&#10;  getAll: () =&gt; ApiClient.get&lt;any[]&gt;(&quot;/Restaurant&quot;),&#10;  getById: (id: string) =&gt; ApiClient.get&lt;any&gt;(`/Restaurant/${id}`),&#10;  create: (data: any) =&gt; ApiClient.post&lt;any&gt;(&quot;/Restaurant&quot;, data),&#10;  update: (id: string, data: any) =&gt; ApiClient.put&lt;any&gt;(`/Restaurant/${id}`, data),&#10;  delete: (id: string) =&gt; ApiClient.delete&lt;any&gt;(`/Restaurant/${id}`),&#10;}&#10;&#10;// Menu API&#10;export const menuApi = {&#10;  getByRestaurant: (restaurantId: string) =&gt; ApiClient.get&lt;any[]&gt;(`/Menu/restaurant/${restaurantId}`),&#10;  getById: (id: string) =&gt; ApiClient.get&lt;any&gt;(`/Menu/${id}`),&#10;  create: (data: any) =&gt; ApiClient.post&lt;any&gt;(&quot;/Menu&quot;, data),&#10;  update: (id: string, data: any) =&gt; ApiClient.put&lt;any&gt;(`/Menu/${id}`, data),&#10;  delete: (id: string) =&gt; ApiClient.delete&lt;any&gt;(`/Menu/${id}`),&#10;}&#10;&#10;// Order API&#10;export const orderApi = {&#10;  getAll: () =&gt; ApiClient.get&lt;any[]&gt;(&quot;/Order&quot;),&#10;  getById: (id: string) =&gt; ApiClient.get&lt;any&gt;(`/Order/${id}`),&#10;  getByCustomer: (customerId: string) =&gt; ApiClient.get&lt;any[]&gt;(`/Order/customer/${customerId}`),&#10;  create: (data: any) =&gt; ApiClient.post&lt;any&gt;(&quot;/Order&quot;, data),&#10;  update: (id: string, data: any) =&gt; ApiClient.put&lt;any&gt;(`/Order/${id}`, data),&#10;  updateStatus: (id: string, status: string) =&gt; ApiClient.patch&lt;any&gt;(`/Order/${id}/status`, { status }),&#10;}&#10;&#10;// Reservation API&#10;export const reservationApi = {&#10;  getAll: () =&gt; ApiClient.get&lt;any[]&gt;(&quot;/Reservation&quot;),&#10;  getById: (id: string) =&gt; ApiClient.get&lt;any&gt;(`/Reservation/${id}`),&#10;  getByCustomer: (customerId: string) =&gt; ApiClient.get&lt;any[]&gt;(`/Reservation/customer/${customerId}`),&#10;  create: (data: any) =&gt; ApiClient.post&lt;any&gt;(&quot;/Reservation&quot;, data),&#10;  update: (id: string, data: any) =&gt; ApiClient.put&lt;any&gt;(`/Reservation/${id}`, data),&#10;  cancel: (id: string) =&gt; ApiClient.delete&lt;any&gt;(`/Reservation/${id}`),&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FrontEnd/Restoran/lib/auth.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FrontEnd/Restoran/lib/auth.ts" />
              <option name="originalContent" value="import { type AppUser, type AuthResponse, UserRole } from &quot;@/types&quot;&#10;&#10;export class AuthService {&#10;  private static TOKEN_KEY = &quot;auth_token&quot;&#10;  private static USER_KEY = &quot;auth_user&quot;&#10;&#10;  private static MOCK_USERS = [&#10;    {&#10;      email: &quot;admin@gmail.com&quot;,&#10;      password: &quot;admin123&quot;,&#10;      user: {&#10;        id: &quot;admin-1&quot;,&#10;        fullName: &quot;Admin User&quot;,&#10;        email: &quot;admin@gmail.com&quot;,&#10;        phoneNumber: &quot;+90 555 000 0001&quot;,&#10;        roles: [UserRole.Admin],&#10;        isActive: true,&#10;      },&#10;    },&#10;    {&#10;      email: &quot;owner@gmail.com&quot;,&#10;      password: &quot;owner123&quot;,&#10;      user: {&#10;        id: &quot;owner-1&quot;,&#10;        fullName: &quot;Restaurant Owner&quot;,&#10;        email: &quot;owner@gmail.com&quot;,&#10;        phoneNumber: &quot;+90 555 000 0002&quot;,&#10;        roles: [UserRole.Owner],&#10;        isActive: true,&#10;        restaurantId: &quot;1&quot;,&#10;      },&#10;    },&#10;    {&#10;      email: &quot;employee@gmail.com&quot;,&#10;      password: &quot;employee123&quot;,&#10;      user: {&#10;        id: &quot;employee-1&quot;,&#10;        fullName: &quot;Restaurant Employee&quot;,&#10;        email: &quot;employee@gmail.com&quot;,&#10;        phoneNumber: &quot;+90 555 000 0003&quot;,&#10;        roles: [UserRole.Employee],&#10;        isActive: true,&#10;        restaurantId: &quot;1&quot;,&#10;      },&#10;    },&#10;    {&#10;      email: &quot;customer@gmail.com&quot;,&#10;      password: &quot;customer123&quot;,&#10;      user: {&#10;        id: &quot;customer-1&quot;,&#10;        fullName: &quot;Customer User&quot;,&#10;        email: &quot;customer@gmail.com&quot;,&#10;        phoneNumber: &quot;+90 555 000 0004&quot;,&#10;        roles: [UserRole.Customer],&#10;        isActive: true,&#10;      },&#10;    },&#10;    {&#10;      email: &quot;delivery@gmail.com&quot;,&#10;      password: &quot;delivery123&quot;,&#10;      user: {&#10;        id: &quot;delivery-1&quot;,&#10;        fullName: &quot;Delivery Person&quot;,&#10;        email: &quot;delivery@gmail.com&quot;,&#10;        phoneNumber: &quot;+90 555 000 0005&quot;,&#10;        roles: [UserRole.Delivery],&#10;        isActive: true,&#10;      },&#10;    },&#10;  ]&#10;&#10;  static async login(email: string, password: string): Promise&lt;AuthResponse&gt; {&#10;    await new Promise((resolve) =&gt; setTimeout(resolve, 500))&#10;&#10;    const mockUser = this.MOCK_USERS.find((u) =&gt; u.email === email &amp;&amp; u.password === password)&#10;&#10;    if (!mockUser) {&#10;      throw new Error(&quot;Login failed&quot;)&#10;    }&#10;&#10;    const token = `mock-jwt-token-${mockUser.user.id}`&#10;    const authResponse: AuthResponse = {&#10;      token,&#10;      user: mockUser.user,&#10;    }&#10;&#10;    this.setToken(authResponse.token)&#10;    this.setUser(authResponse.user)&#10;    return authResponse&#10;  }&#10;&#10;  static async register(&#10;    fullName: string,&#10;    email: string,&#10;    password: string,&#10;    phoneNumber?: string,&#10;  ): Promise&lt;AuthResponse&gt; {&#10;    // Simulate API delay&#10;    await new Promise((resolve) =&gt; setTimeout(resolve, 800))&#10;&#10;    // Check if user already exists&#10;    const existingUser = this.MOCK_USERS.find((u) =&gt; u.email === email)&#10;    if (existingUser) {&#10;      throw new Error(&quot;User already exists&quot;)&#10;    }&#10;&#10;    // Create new user with Customer role by default&#10;    const newUser: AppUser = {&#10;      id: `user-${Date.now()}`,&#10;      fullName,&#10;      email,&#10;      phoneNumber: phoneNumber || &quot;&quot;,&#10;      roles: [UserRole.Customer],&#10;      isActive: true,&#10;    }&#10;&#10;    const token = `mock-jwt-token-${newUser.id}`&#10;    const authResponse: AuthResponse = {&#10;      token,&#10;      user: newUser,&#10;    }&#10;&#10;    // Add to mock users list (in-memory only)&#10;    this.MOCK_USERS.push({&#10;      email,&#10;      password,&#10;      user: newUser,&#10;    })&#10;&#10;    this.setToken(authResponse.token)&#10;    this.setUser(authResponse.user)&#10;    return authResponse&#10;  }&#10;&#10;  static logout(): void {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      localStorage.removeItem(this.TOKEN_KEY)&#10;      localStorage.removeItem(this.USER_KEY)&#10;    }&#10;  }&#10;&#10;  static getToken(): string | null {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      return localStorage.getItem(this.TOKEN_KEY)&#10;    }&#10;    return null&#10;  }&#10;&#10;  static setToken(token: string): void {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      localStorage.setItem(this.TOKEN_KEY, token)&#10;    }&#10;  }&#10;&#10;  static getUser(): AppUser | null {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      const userStr = localStorage.getItem(this.USER_KEY)&#10;      return userStr ? JSON.parse(userStr) : null&#10;    }&#10;    return null&#10;  }&#10;&#10;  static setUser(user: AppUser): void {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      localStorage.setItem(this.USER_KEY, JSON.stringify(user))&#10;    }&#10;  }&#10;&#10;  static isAuthenticated(): boolean {&#10;    return !!this.getToken()&#10;  }&#10;&#10;  static hasRole(role: UserRole): boolean {&#10;    const user = this.getUser()&#10;    return user?.roles?.includes(role) ?? false&#10;  }&#10;&#10;  static getPrimaryRole(): UserRole | null {&#10;    const user = this.getUser()&#10;    if (!user?.roles || user.roles.length === 0) return null&#10;&#10;    const rolePriority = [UserRole.Admin, UserRole.Owner, UserRole.Employee, UserRole.Delivery, UserRole.Customer]&#10;&#10;    for (const role of rolePriority) {&#10;      if (user.roles.includes(role)) return role&#10;    }&#10;&#10;    return user.roles[0]&#10;  }&#10;&#10;  static getRedirectPath(): string {&#10;    const role = this.getPrimaryRole()&#10;&#10;    switch (role) {&#10;      case UserRole.Admin:&#10;        return &quot;/admin/dashboard&quot;&#10;      case UserRole.Owner:&#10;        return &quot;/owner/dashboard&quot;&#10;      case UserRole.Employee:&#10;        return &quot;/employee/dashboard&quot;&#10;      case UserRole.Delivery:&#10;        return &quot;/delivery/orders&quot;&#10;      case UserRole.Customer:&#10;      default:&#10;        return &quot;/customer&quot;&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { type AppUser, type AuthResponse, UserRole } from &quot;@/types&quot;&#10;&#10;const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || &quot;http://localhost:5000/api&quot;&#10;&#10;export class AuthService {&#10;  private static TOKEN_KEY = &quot;auth_token&quot;&#10;  private static USER_KEY = &quot;auth_user&quot;&#10;&#10;  static async login(email: string, password: string): Promise&lt;AuthResponse&gt; {&#10;    try {&#10;      const response = await fetch(`${API_BASE_URL}/Account/login`, {&#10;        method: &quot;POST&quot;,&#10;        headers: {&#10;          &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        },&#10;        body: JSON.stringify({ Email: email, Password: password }),&#10;      })&#10;&#10;      if (!response.ok) {&#10;        const errorText = await response.text()&#10;        console.error(&quot;Login error response:&quot;, errorText)&#10;&#10;        try {&#10;          const error = JSON.parse(errorText)&#10;          throw new Error(error.message || error.Message || &quot;Login failed&quot;)&#10;        } catch (e) {&#10;          throw new Error(&quot;Login failed&quot;)&#10;        }&#10;      }&#10;&#10;      const data = await response.json()&#10;&#10;      // Backend'den gelen response yapısı: { message, token, user: { id, userName, email, firstName, lastName, roles } }&#10;      const user: AppUser = {&#10;        id: data.user.id,&#10;        fullName: data.user.userName || data.user.email,&#10;        email: data.user.email,&#10;        phoneNumber: data.user.phoneNumber || &quot;&quot;,&#10;        roles: data.user.roles?.map((role: string) =&gt; role as UserRole) || [UserRole.Customer],&#10;        isActive: true,&#10;      }&#10;&#10;      const authResponse: AuthResponse = {&#10;        token: data.token,&#10;        user,&#10;      }&#10;&#10;      this.setToken(authResponse.token)&#10;      this.setUser(authResponse.user)&#10;      return authResponse&#10;    } catch (error) {&#10;      console.error(&quot;Login error:&quot;, error)&#10;      throw error&#10;    }&#10;  }&#10;&#10;  static async register(&#10;    fullName: string,&#10;    email: string,&#10;    password: string,&#10;    phoneNumber?: string,&#10;    address?: string,&#10;  ): Promise&lt;AuthResponse&gt; {&#10;    try {&#10;      const requestBody = {&#10;        FullName: fullName,&#10;        Email: email,&#10;        Password: password,&#10;        ConfirmPassword: password,&#10;        Phone: phoneNumber || &quot;&quot;,&#10;        Address: address || &quot;&quot;,&#10;      }&#10;&#10;      console.log(&quot;Register request:&quot;, requestBody)&#10;&#10;      const response = await fetch(`${API_BASE_URL}/Account/register`, {&#10;        method: &quot;POST&quot;,&#10;        headers: {&#10;          &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        },&#10;        body: JSON.stringify(requestBody),&#10;      })&#10;&#10;      console.log(&quot;Register response status:&quot;, response.status)&#10;&#10;      if (!response.ok) {&#10;        const errorText = await response.text()&#10;        console.error(&quot;Register error response:&quot;, errorText)&#10;&#10;        try {&#10;          const error = JSON.parse(errorText)&#10;          throw new Error(error.message || error.title || &quot;Registration failed&quot;)&#10;        } catch (e) {&#10;          throw new Error(errorText || &quot;Registration failed&quot;)&#10;        }&#10;      }&#10;&#10;      const data = await response.json()&#10;      console.log(&quot;Register success response:&quot;, data)&#10;&#10;      // Backend'den gelen response yapısı: { message, token, user: { id, userName, email, firstName, lastName } }&#10;      const user: AppUser = {&#10;        id: data.user.id,&#10;        fullName: data.user.userName || fullName,&#10;        email: data.user.email,&#10;        phoneNumber: phoneNumber || &quot;&quot;,&#10;        roles: [UserRole.Customer], // Yeni kullanıcı default olarak Customer&#10;        isActive: true,&#10;      }&#10;&#10;      const authResponse: AuthResponse = {&#10;        token: data.token,&#10;        user,&#10;      }&#10;&#10;      this.setToken(authResponse.token)&#10;      this.setUser(authResponse.user)&#10;      return authResponse&#10;    } catch (error) {&#10;      console.error(&quot;Registration error:&quot;, error)&#10;      throw error&#10;    }&#10;  }&#10;&#10;  static logout(): void {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      localStorage.removeItem(this.TOKEN_KEY)&#10;      localStorage.removeItem(this.USER_KEY)&#10;    }&#10;  }&#10;&#10;  static getToken(): string | null {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      return localStorage.getItem(this.TOKEN_KEY)&#10;    }&#10;    return null&#10;  }&#10;&#10;  static setToken(token: string): void {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      localStorage.setItem(this.TOKEN_KEY, token)&#10;    }&#10;  }&#10;&#10;  static getUser(): AppUser | null {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      const userStr = localStorage.getItem(this.USER_KEY)&#10;      return userStr ? JSON.parse(userStr) : null&#10;    }&#10;    return null&#10;  }&#10;&#10;  static setUser(user: AppUser): void {&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      localStorage.setItem(this.USER_KEY, JSON.stringify(user))&#10;    }&#10;  }&#10;&#10;  static isAuthenticated(): boolean {&#10;    return !!this.getToken()&#10;  }&#10;&#10;  static hasRole(role: UserRole): boolean {&#10;    const user = this.getUser()&#10;    return user?.roles?.includes(role) ?? false&#10;  }&#10;&#10;  static getPrimaryRole(): UserRole | null {&#10;    const user = this.getUser()&#10;    if (!user?.roles || user.roles.length === 0) return null&#10;&#10;    const rolePriority = [UserRole.Admin, UserRole.Owner, UserRole.Employee, UserRole.Delivery, UserRole.Customer]&#10;&#10;    for (const role of rolePriority) {&#10;      if (user.roles.includes(role)) return role&#10;    }&#10;&#10;    return user.roles[0]&#10;  }&#10;&#10;  static getRedirectPath(): string {&#10;    const role = this.getPrimaryRole()&#10;&#10;    switch (role) {&#10;      case UserRole.Admin:&#10;        return &quot;/admin/dashboard&quot;&#10;      case UserRole.Owner:&#10;        return &quot;/owner/dashboard&quot;&#10;      case UserRole.Employee:&#10;        return &quot;/employee/dashboard&quot;&#10;      case UserRole.Delivery:&#10;        return &quot;/delivery/orders&quot;&#10;      case UserRole.Customer:&#10;      default:&#10;        return &quot;/customer&quot;&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Src/Core/RestaurantManagment.Application/Common/DTOs/JobPosting/JobPostingDto.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Src/Core/RestaurantManagment.Application/Common/DTOs/JobPosting/JobPostingDto.cs" />
              <option name="updatedContent" value="namespace RestaurantManagment.Application.Common.DTOs.JobPosting;&#10;&#10;public class JobPostingDto&#10;{&#10;    public string Id { get; set; } = string.Empty;&#10;    public string Title { get; set; } = string.Empty;&#10;    public string Description { get; set; } = string.Empty;&#10;    public string Requirements { get; set; } = string.Empty;&#10;    public string Position { get; set; } = string.Empty;&#10;    public decimal? Salary { get; set; }&#10;    public string EmploymentType { get; set; } = string.Empty;&#10;    public DateTime PostedDate { get; set; }&#10;    public DateTime? ExpiryDate { get; set; }&#10;    public bool IsActive { get; set; }&#10;    public string RestaurantId { get; set; } = string.Empty;&#10;    public string RestaurantName { get; set; } = string.Empty;&#10;    public int ApplicationCount { get; set; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Src/Core/RestaurantManagment.Domain/Models/Common/TopSellingItemDto.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Src/Core/RestaurantManagment.Domain/Models/Common/TopSellingItemDto.cs" />
              <option name="updatedContent" value="namespace RestaurantManagment.Domain.Models.Common;&#10;&#10;public class TopSellingItemDto&#10;{&#10;    public string MenuItemId { get; set; } = string.Empty;&#10;    public string MenuItemName { get; set; } = string.Empty;&#10;    public int QuantitySold { get; set; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Src/Infrastructure/RestaurantManagment.Persistance/Configurations/JobPostingConfiguration.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Src/Infrastructure/RestaurantManagment.Persistance/Configurations/JobPostingConfiguration.cs" />
              <option name="updatedContent" value="using Microsoft.EntityFrameworkCore;&#10;using Microsoft.EntityFrameworkCore.Metadata.Builders;&#10;using RestaurantManagment.Domain.Models;&#10;&#10;namespace RestaurantManagment.Persistance.Configurations;&#10;&#10;public class JobPostingConfiguration : IEntityTypeConfiguration&lt;JobPosting&gt;&#10;{&#10;    public void Configure(EntityTypeBuilder&lt;JobPosting&gt; builder)&#10;    {&#10;        builder.HasKey(j =&gt; j.Id);&#10;&#10;        builder.Property(j =&gt; j.Title)&#10;            .IsRequired()&#10;            .HasMaxLength(200);&#10;&#10;        builder.Property(j =&gt; j.Description)&#10;            .IsRequired()&#10;            .HasMaxLength(2000);&#10;&#10;        builder.Property(j =&gt; j.Requirements)&#10;            .IsRequired()&#10;            .HasMaxLength(1000);&#10;&#10;        builder.Property(j =&gt; j.Position)&#10;            .IsRequired()&#10;            .HasMaxLength(100);&#10;&#10;        builder.Property(j =&gt; j.EmploymentType)&#10;            .IsRequired()&#10;            .HasMaxLength(50);&#10;&#10;        // Relationships&#10;        builder.HasOne(j =&gt; j.Restaurant)&#10;            .WithMany(r =&gt; r.JobPostings)&#10;            .HasForeignKey(j =&gt; j.RestaurantId)&#10;            .OnDelete(DeleteBehavior.Cascade);&#10;&#10;        // Indexes&#10;        builder.HasIndex(j =&gt; j.RestaurantId);&#10;        builder.HasIndex(j =&gt; j.IsActive);&#10;&#10;        // Soft Delete Query Filter&#10;        builder.HasQueryFilter(j =&gt; !j.IsDeleted);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Src/Presentation/RestaurantManagment.WebAPI/Controllers/AccountController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Src/Presentation/RestaurantManagment.WebAPI/Controllers/AccountController.cs" />
              <option name="updatedContent" value="using AutoMapper;&#13;&#10;using Microsoft.AspNetCore.Identity;&#13;&#10;using Microsoft.AspNetCore.Mvc;&#13;&#10;using RestaurantManagment.Application.Common.DTOs.Account;&#13;&#10;using RestaurantManagment.Domain.Models;&#13;&#10;using RestaurantManagment.Infrastructure.Services;&#13;&#10;&#13;&#10;namespace RestaurantManagment.WebAPI.Controllers&#13;&#10;{&#13;&#10;    [Route(&quot;api/[controller]&quot;)]&#13;&#10;    [ApiController]&#13;&#10;    public class AccountController(&#13;&#10;        UserManager&lt;AppUser&gt; userManager,&#13;&#10;        SignInManager&lt;AppUser&gt; signInManager,&#13;&#10;        RoleManager&lt;IdentityRole&gt; roleManager,&#13;&#10;        IMapper mapper,&#13;&#10;        IJwtTokenService jwtTokenService) : Controller&#13;&#10;    {&#13;&#10;        [HttpPost(&quot;register&quot;)]&#13;&#10;        public async Task&lt;IActionResult&gt; Register(UserRegisterDto userRegisterDto)&#13;&#10;        {&#13;&#10;            if (!ModelState.IsValid)&#13;&#10;                return BadRequest(ModelState);&#13;&#10;            &#13;&#10;            var user = mapper.Map&lt;AppUser&gt;(userRegisterDto);&#13;&#10;&#13;&#10;            var result = await userManager.CreateAsync(user, userRegisterDto.Password);&#13;&#10;            if (!result.Succeeded)&#13;&#10;            {&#13;&#10;                foreach (var error in result.Errors)&#13;&#10;                {&#13;&#10;                    ModelState.AddModelError(error.Code, error.Description);&#13;&#10;                }&#13;&#10;&#13;&#10;                return BadRequest(ModelState);&#13;&#10;            }&#13;&#10;            &#13;&#10;            await userManager.AddToRoleAsync(user, &quot;Customer&quot;);&#13;&#10;            &#13;&#10;            var token = await jwtTokenService.GenerateTokenAsync(user);&#13;&#10;            &#13;&#10;            return Ok(new { &#13;&#10;                Message = &quot;User registered successfully&quot;,&#13;&#10;                Token = token,&#13;&#10;                User = new {&#13;&#10;                    user.Id,&#13;&#10;                    user.UserName,&#13;&#10;                    user.Email,&#13;&#10;                }&#13;&#10;            });&#13;&#10;        }&#13;&#10;&#13;&#10;        [HttpPost(&quot;login&quot;)]&#13;&#10;        public async Task&lt;IActionResult&gt; Login(UserLoginDto userLoginDto)&#13;&#10;        {&#13;&#10;            if (!ModelState.IsValid)&#13;&#10;                return BadRequest(ModelState);&#13;&#10;            &#13;&#10;            var user = await userManager.FindByEmailAsync(userLoginDto.Email);&#13;&#10;            if (user == null)&#13;&#10;            {&#13;&#10;                return Unauthorized(new { Message = &quot;Invalid email or password&quot; });&#13;&#10;            }&#13;&#10;&#13;&#10;            var result = await signInManager.CheckPasswordSignInAsync(user, userLoginDto.Password, false);&#13;&#10;            if (!result.Succeeded)&#13;&#10;            {&#13;&#10;                return Unauthorized(new { Message = &quot;Invalid email or password&quot; });&#13;&#10;            }&#13;&#10;&#13;&#10;            var token = await jwtTokenService.GenerateTokenAsync(user);&#13;&#10;            var roles = await userManager.GetRolesAsync(user);&#13;&#10;&#13;&#10;            return Ok(new { &#13;&#10;                Message = &quot;Login successful&quot;,&#13;&#10;                Token = token,&#13;&#10;                User = new {&#13;&#10;                    user.Id,&#13;&#10;                    user.UserName,&#13;&#10;                    user.Email,&#13;&#10;                    Roles = roles&#13;&#10;                }&#13;&#10;            });&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>